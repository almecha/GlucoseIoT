## nota: el broker no funciona as√≠ que no lo puedo probar, pero creemos q funciona

import telepot
from telepot.loop import MessageLoop
import json
import cherrypy
import threading
import time
from datetime import datetime, timedelta, timezone
from telepot.namedtuple import InlineKeyboardMarkup, InlineKeyboardButton, ReplyKeyboardMarkup, KeyboardButton
from MyMQTT import *

class MyBot:
    exposed = True

    def __init__(self, token):
        self.tokenBot = token
        self.bot = telepot.Bot(self.tokenBot)
        self.chat_ids = {}  # {user_id: chat_id}

        # --- Configuraci√≥n MQTT ---
        self.mqtt_broker = "mqtt.eclipseprojects.io"
        self.mqtt_port = 1883
        self.mqtt_client_id = "your_bot_telegram_client_id" # Cambia esto a un ID √∫nico para tu bot
        self.mqtt_topic_subscribe = 'IoT/heart_rate'
        self.danger_data_log = [] # Para almacenar los mensajes de peligro, como en tu suscriptor original

        # Instanciar el cliente MQTT, pas√°ndose a s√≠ mismo (self) como el notifier
        self.mqtt_client = MyMQTT(self.mqtt_client_id, self.mqtt_broker, self.mqtt_port, self)
        # --- Fin Configuraci√≥n MQTT ---

        MessageLoop(self.bot, {
            'chat': self.on_chat_message,
            'callback_query': self.on_callback_query
        }).run_as_thread()
        print("ü§ñ Bot is listening...")

        # Iniciar el suscriptor MQTT despu√©s de que el bot est√© configurado
        self.start_mqtt_subscriber()

    # --- M√©todos MQTT ---
    def start_mqtt_subscriber(self):
        print(f"Starting MQTT subscriber for topic: {self.mqtt_topic_subscribe}")
        self.mqtt_client.start()
        self.mqtt_client.mySubscribe(self.mqtt_topic_subscribe)

    def stop_mqtt_subscriber(self):
        print("Stopping MQTT subscriber...")
        self.mqtt_client.unsubscribe()
        self.mqtt_client.stop()

    def notify(self, topic, payload):
        """
        Este m√©todo es llamado por MyMQTT cuando se recibe un mensaje MQTT.
        Actuar√° como el antiguo notify de HeartRateSubscriber.
        """
        print(f"Received MQTT message from topic {topic}")
        try:
            message_received = json.loads(payload)
            # Asumo que la estructura es como en tu ejemplo: {"e": [{"v": 150}]}
            heart_rate = int(message_received.get("e", [{}])[0].get("v"))
            measurement_time = message_received.get("bn") # O cualquier otro campo de tiempo

            if heart_rate in range(60, 100):
                print(f"Heart rate {heart_rate}: Normal range")
            elif heart_rate in range(100, 140):
                print(f"Heart rate {heart_rate}: Sport")
            elif heart_rate in range(140, 180):
                print(f"Heart rate {heart_rate}: DANGER ({heart_rate} BPM)")
                # Almacenar en el log
                self.danger_data_log.append(message_received)
                with open('dangerdata_log.json', 'w') as f:
                    json.dump(self.danger_data_log, f, indent=4)

                # ENVIAR ALERTA A LOS USUARIOS REGISTRADOS EN TELEGRAM
                alert_message = f"üö® DANGER! High Heart Rate: {heart_rate} BPM!\n" \
                                f"Time: {measurement_time if measurement_time else self.get_turin_time_str_no_pytz()}"
                
                # Iterar sobre todos los chat_ids registrados y enviar la alerta
                if self.chat_ids:
                    for user_id, chat_id in self.chat_ids.items():
                        try:
                            self.bot.sendMessage(chat_id, text=alert_message)
                            print(f"[INFO] Sent DANGER alert to chat_id: {chat_id} (User: {user_id})")
                        except Exception as e:
                            print(f"[ERROR] Failed to send Telegram message to {chat_id}: {e}")
                else:
                    print("[WARNING] No chat IDs registered to send heart rate alerts.")

            else:
                print(f"Heart rate {heart_rate}: Out of range")

        except json.JSONDecodeError as e:
            print(f"[ERROR] MQTT Payload is not valid JSON: {payload}. Error: {e}")
        except (KeyError, IndexError, ValueError) as e:
            print(f"[ERROR] MQTT Payload structure error or value conversion error: {payload}. Error: {e}")
    # --- Fin M√©todos MQTT ---


    def get_turin_time_str_no_pytz(self):
        current_utc_time = datetime.now(timezone.utc)
        turin_time = current_utc_time + timedelta(hours=2)
        return turin_time.strftime('%Y-%m-%d %H:%M:%S (UTC+2 asumido)')

    def on_callback_query(self, msg):
        query_id, from_id, query_data = telepot.glance(msg, flavor='callback_query')
        chat_ID = msg['message']['chat']['id']
        message_id = msg['message']['message_id']

        print(f"[INFO] Callback query from user {from_id}: {query_data}")
        current_turin_time = self.get_turin_time_str_no_pytz()

        self.bot.answerCallbackQuery(query_id, text=f"Action: {query_data.replace('action_', '').replace('_', ' ').title()}")

        if query_data == 'action_record_meal':
            response_text = f"‚úÖ Meal recorded via button at: {current_turin_time}"
            self.bot.editMessageText((chat_ID, message_id), text=response_text)
            print(f"[INFO] User {from_id} recorded a meal via button at {current_turin_time}")
        elif query_data.startswith('action_insulin_'):
            try:
                insulin_amount = int(query_data.split('_')[2])
                response_text = f"üíâ Insulin recorded via button: {insulin_amount} units at: {current_turin_time}"
                self.bot.editMessageText((chat_ID, message_id), text=response_text)
                print(f"[INFO] User {from_id} recorded {insulin_amount} units of insulin via button at {current_turin_time}")
            except (ValueError, IndexError):
                response_text = "üö´ Error parsing insulin amount from button."
                self.bot.editMessageText((chat_ID, message_id), text=response_text)
        else:
            response_text = f"Unhandled callback data: {query_data}"
            self.bot.editMessageText((chat_ID, message_id), text=response_text)

    def on_chat_message(self, msg):
        content_type, chat_type, chat_ID = telepot.glance(msg)
        user_id = msg['from']['id']
        message = msg.get('text', '')

        self.chat_ids[user_id] = chat_ID
        print(f"[INFO] Registered user_id={user_id} with chat_id={chat_ID}")

        current_turin_time = self.get_turin_time_str_no_pytz()

        if message.startswith('/'):
            command = message.split(' ', 1)[0]
            args = message.split(' ', 1)[1] if len(message.split(' ', 1)) > 1 else ''

            if command == '/start':
                main_keyboard = ReplyKeyboardMarkup(keyboard=[
                    [KeyboardButton(text='/meal')],
                    [KeyboardButton(text='/insulin')],
                    [KeyboardButton(text='/helloworld')]
                ], resize_keyboard=True, one_time_keyboard=False)

                self.bot.sendMessage(chat_ID,
                                     text="üëã Welcome to your Health Tracker Bot!\n\n"
                                          "Use the buttons below or type a command:\n"
                                          "Use /meal to record a meal.\n"
                                          "Use /insulin to record insulin intake.\n\n"
                                          "Your chat ID has been registered for alerts.",
                                     reply_markup=main_keyboard)
                print(f"[INFO] User {user_id} started the bot. Chat ID: {chat_ID}")

            elif command == '/helloworld':
                self.bot.sendMessage(chat_ID, text="Hello World!")

            elif command == '/meal':
                keyboard_confirm_meal = InlineKeyboardMarkup(inline_keyboard=[
                    [InlineKeyboardButton(text='Confirm Meal üçΩÔ∏è', callback_data='action_record_meal')],
                ])
                self.bot.sendMessage(chat_ID, text="Confirm recording meal?", reply_markup=keyboard_confirm_meal)
                print(f"[INFO] User {user_id} requested meal recording, waiting for confirmation.")

            elif command == '/insulin':
                if not args.strip():
                    insulin_buttons = []
                    row = []
                    for i in range(1, 16):
                        row.append(InlineKeyboardButton(text=str(i), callback_data=f'action_insulin_{i}'))
                        if len(row) == 5:
                            insulin_buttons.append(row)
                            row = []
                    if row:
                        insulin_buttons.append(row)

                    keyboard_select_insulin = InlineKeyboardMarkup(inline_keyboard=insulin_buttons)
                    self.bot.sendMessage(chat_ID, text="Please select insulin amount (units):", reply_markup=keyboard_select_insulin)
                    print(f"[INFO] User {user_id} requested insulin, prompted to select amount.")
                elif args.strip().isdigit():
                    insulin_amount = int(args.strip())
                    if 1 <= insulin_amount <= 15:
                        keyboard_confirm_insulin = InlineKeyboardMarkup(inline_keyboard=[
                            [InlineKeyboardButton(text=f'Confirm {insulin_amount} units üíâ', callback_data=f'action_insulin_{insulin_amount}')]
                        ])
                        self.bot.sendMessage(chat_ID, text=f"Confirm insulin amount: {insulin_amount} units?", reply_markup=keyboard_confirm_insulin)
                        print(f"[INFO] User {user_id} requested insulin recording ({insulin_amount} units), waiting for confirmation.")
                    else:
                        self.bot.sendMessage(chat_ID, text="üö´ Insulin amount must be between 1 and 15. Please select from buttons or type a valid number.")
                else:
                    response_text = "üö´ Please specify the insulin amount in numbers (e.g., /insulin 10) or use the buttons."
                    self.bot.sendMessage(chat_ID, text=response_text)
            else:
                self.bot.sendMessage(chat_ID, text=f"Unknown command: {command}. Try /meal or /insulin.")
        else:
            self.bot.sendMessage(chat_ID, text="You sent:\n" + message + " at: " + current_turin_time)

    def POST(self, *uri, **params):
        try:
            body = cherrypy.request.body.read()
            data = json.loads(body)

            user_id = data.get("userID")
            alert = data.get("alert", "")
            action = data.get("action", "")

            print(f"[DEBUG] Available chat_ids: {self.chat_ids}")

            if not user_id or user_id not in self.chat_ids:
                return json.dumps({
                    "error": "Chat ID not registered. User must send a message in Telegram first."
                })

            chat_id = self.chat_ids[user_id]
            message = f"üö® ALERT: {alert}\nüíâ ACTION: {action}"
            self.bot.sendMessage(chat_id, message)
            return json.dumps({"status": "Message sent"})
        except Exception as e:
            return json.dumps({"error": str(e)})

# ======================
if __name__ == '__main__':
    with open("config.json", "r") as f:
        configuration = json.load(f)
        token_bot = configuration['token']

    mybot = MyBot(token_bot)

    # A√±adir un try-except-finally para asegurar que el suscriptor MQTT se detenga limpiamente
    # cuando el programa se cierra (ej. con Ctrl+C)
    try:
        cherrypy.engine.start()
        cherrypy.engine.block() # Esto bloquear√° el hilo principal hasta que CherryPy se detenga
    except KeyboardInterrupt:
        print("Deteniendo bot y suscriptor MQTT...")
        mybot.stop_mqtt_subscriber() # Llamar al m√©todo para detener el suscriptor
        cherrypy.engine.stop() # Detener el motor de CherryPy
    except Exception as e:
        print(f"An error occurred: {e}")
        mybot.stop_mqtt_subscriber()
        cherrypy.engine.stop()
